// I hope you like spaghetti code

// This code is a bit of a mess, at least in a small part due to the fact that we switch between
// four distinct representations for expressions:
// * Raw strings (for input only)
// * An inductive representation (or the poor man's version thereof, courtesy of JS)
// * The same sort-of inductive representation serialized as a string
// * The HTML representation (the node you actually see)
// HTML nodes actually store the serialized inductive representation of their contents via their
// `data-expr` attribute.

// DOM nodes
var proof               = document.getElementById("proof");
var proof_top           = document.getElementById("proof-top");
var premises_holder     = document.getElementById("premises");
var input_panel         = document.getElementById("input-panel");
var input_panel_title   = document.getElementById("input-panel-title");
var input_panel_field   = document.getElementById("input-panel-field");
var input_panel_confirm = document.getElementById("input-panel-confirm");
var input_panel_error   = document.getElementById("input-panel-error-message");
var intro_rules_holder  = document.getElementById("intro-rules-holder");
var level_panel         = document.getElementById("level-panel");
var focus               = document.getElementById("focus");
var drag_box            = document.getElementById("drag-box");
var intro_rules         = document.getElementById("intro-rules");
var elim_rules          = document.getElementById("elim-rules");
var special_rules       = document.getElementById("special-rules");
var done_message        = document.getElementById("done-message");
var change_button       = document.getElementById("change-button");
var as_premise_button   = document.getElementById("as-premise-button");
var add_premise_button  = document.getElementById("add-premise-button");
var level_gallery       = document.getElementById("level-gallery");


// Configuration
var exercise_mode = true;
var current_exercise = 0; // overridden when loading persistent data
const version = 1; // for import/export


// Exercises
const exercise_1 = '{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Impl","e1":{"type":"Var","name":"B"},"e2":{"type":"Var","name":"A"}}}';
const exercise_2 = '{"type":"Impl","e1":{"type":"False"},"e2":{"type":"Var","name":"A"}}';
const exercise_3 = '{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Or","e1":{"type":"Var","name":"B"},"e2":{"type":"Var","name":"C"}}}';
const premises_3 = ['{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Var","name":"B"}}'];
const exercise_4 = '{"type":"Var","name":"B"}';
const premises_4 = [
  '{"type":"Not","e":{"type":"Var","name":"C"}}',
  '{"type":"Impl","e1":{"type":"Not","e":{"type":"Var","name":"B"}},"e2":{"type":"Var","name":"C"}}',
];
const exercise_5 = '{"type":"Not","e":{"type":"And","e1":{"type":"Not","e":{"type":"Var","name":"A"}},"e2":{"type":"Var","name":"B"}}}';
const premises_5 = ['{"type":"Var","name":"A"}'];
const exercise_6 = '{"type":"Impl","e1":{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Not","e":{"type":"Var","name":"A"}}},"e2":{"type":"Not","e":{"type":"Var","name":"A"}}}';
const exercise_7 = '{"type":"Iff","e1":{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Var","name":"B"}},"e2":{"type":"Impl","e1":{"type":"Not","e":{"type":"Var","name":"B"}},"e2":{"type":"Not","e":{"type":"Var","name":"A"}}}}';

function make_exercise(objective, premises) {
  return {objective: objective, premises: premises, save_data: null};
}

var exercises_data = [
  make_exercise(exercise_1, []), make_exercise(exercise_2, []),
  make_exercise(exercise_3, premises_3), make_exercise(exercise_4, premises_4),
  make_exercise(exercise_5, premises_5), make_exercise(exercise_6, []),
  make_exercise(exercise_7, []),
];


// Conversions between different representations
// String -> Inductive <-> Serialized inductive
//               \-------> HTML
// Serializing/deserializing done via JSON.stringify/JSON.parse
// String to inductive done in a later section (see tokenize and parse_input_field functions)
function tree_to_html(tree) { // Serialized inductive -> HTML
  function tree_to_html_aux(tree) {
    switch (tree.type) {
      case "Var"  : return `<div class='expr'>${tree.name}</div>`;
      case "False": return `<div class='expr'>⊥</div>`;
      case "Not"  : return `<div class='expr'> ¬${tree_to_html_aux(tree.e)} </div>`;
      case "And":
        return `<div class='expr'>${tree_to_html_aux(tree.e1)} ∧ ${tree_to_html_aux(tree.e2)}</div>`;
      case "Or":
        return `<div class='expr'>${tree_to_html_aux(tree.e1)} ∨ ${tree_to_html_aux(tree.e2)}</div>`;
      case "Impl":
        return `<div class='expr'>${tree_to_html_aux(tree.e1)} → ${tree_to_html_aux(tree.e2)}</div>`;
      case "Iff":
        return `<div class='expr'>${tree_to_html_aux(tree.e1)} ↔ ${tree_to_html_aux(tree.e2)}</div>`;
      default: return null;
    }
  }

  switch (tree.type) { // First level is not wrapped in an expr node
    case "Var"  : return `${tree.name}`;
    case "False": return `⊥`;
    case "Not"  : return ` ¬${tree_to_html_aux(tree.e)}`;
    case "And"  : return `${tree_to_html_aux(tree.e1)} ∧ ${tree_to_html_aux(tree.e2)}`;
    case "Or"   : return `${tree_to_html_aux(tree.e1)} ∨ ${tree_to_html_aux(tree.e2)}`;
    case "Impl" : return `${tree_to_html_aux(tree.e1)} → ${tree_to_html_aux(tree.e2)}`;
    case "Iff"  : return `${tree_to_html_aux(tree.e1)} ↔ ${tree_to_html_aux(tree.e2)}`;
    default: return null;
  }
}


// Proof status
function check_whether_proof_done() {
  if (proof.children[0].children[2].children[0].classList.contains("known")) {
    drag_box.classList.add("known");
    level_gallery.children[current_exercise].classList.add("known");
  } else {
    drag_box.classList.remove("known");
    level_gallery.children[current_exercise].classList.remove("known");
  }
}

function update_status_of_lower_tree(level) {
  function are_all_immediately_above_known(level) {
    let above_hyps = level.parentNode.parentNode.children[0];
    if (above_hyps) {
      for (h of above_hyps.children) {
        if (!h.children[2].children[0].classList.contains("known")) {
          return false;
        }
      }
      return true;
    }
  }

  if (level.classList.contains("expr") && are_all_immediately_above_known(level)) {
    level.classList.add("known");
    if (level.parentNode.parentNode.parentNode.parentNode.id != "proof-top") {
      update_status_of_lower_tree(
        level.parentNode.parentNode.parentNode.parentNode.children[2].children[0]
      );
    }
  }
}



// Level management
function populate_level_selector() { // Dynamically, using exercises_data
  for (let i = 0; i < exercises_data.length; i++) {
    level_gallery.insertAdjacentHTML(
      "beforeend",
      `<div class="gallery-item" onclick="switch_to_level(${i})"><div class=gallery-title>Ex. ${i+1}</div><hr/><div class=gallery-description>${tree_to_html(JSON.parse(exercises_data[i].objective))}</div></div>`
    );
  }
  for (let i = 0; i < 3; i++) {
    level_gallery.insertAdjacentHTML(
      "beforeend",
      `<div class=gallery-i-wish-i-didnt-have-to-resort-to-this-dirty-hack></div>`
    );
  }
}

function save_level_aux(node) {
  let sep = node.parentNode.parentNode.children[1];
  let above = node.parentNode.parentNode.children[0];

  function get_nth_above_child_expr(n) {
    return above.children[n].children[2].children[0].getAttribute("data-expr");
  }

  function gen_subactions() {
    let subactions = [];
    for (c of above.children) {
      subactions.push(save_level_aux(c.children[2].children[0]));
    }
    return subactions;
  }

  if (sep.innerHTML != "") { // The rule that was used is "physically" printed on the separation bar
    switch (sep.children[1].innerHTML) {
      case "↔-elim-l":        return { type: sep.children[1].innerHTML, arg: get_nth_above_child_expr(1), subactions: gen_subactions(), };
      case "↔-elim-r":        return { type: sep.children[1].innerHTML, arg: get_nth_above_child_expr(1), subactions: gen_subactions(), };
      case "∧-elim-l":        return { type: sep.children[1].innerHTML, arg: JSON.stringify(JSON.parse(get_nth_above_child_expr(0)).e2), subactions: gen_subactions(), };
      case "∧-elim-r":        return { type: sep.children[1].innerHTML, arg: JSON.stringify(JSON.parse(get_nth_above_child_expr(0)).e1), subactions: gen_subactions(), };
      case "∨-elim":          return { type: sep.children[1].innerHTML, arg: get_nth_above_child_expr(0), subactions: gen_subactions(), };
      case "DNE (classical)": return { type: sep.children[1].innerHTML, subactions: gen_subactions(), };
      case "⊥-elim":          return { type: sep.children[1].innerHTML, subactions: gen_subactions() };
      case "→-elim":          return { type: sep.children[1].innerHTML, arg: get_nth_above_child_expr(0), subactions: gen_subactions() };
      case "¬-elim":          return { type: sep.children[1].innerHTML, arg: get_nth_above_child_expr(0), subactions: gen_subactions() };
      case "¬-intro":         return { type: sep.children[1].innerHTML, subactions: gen_subactions() };
      case "∧-intro":         return { type: sep.children[1].innerHTML, subactions: gen_subactions() };
      case "∨-intro-l":       return { type: sep.children[1].innerHTML, subactions: gen_subactions() };
      case "∨-intro-r":       return { type: sep.children[1].innerHTML, subactions: gen_subactions() };
      case "→-intro":         return { type: sep.children[1].innerHTML, subactions: gen_subactions() };
      case "↔-intro":         return { type: sep.children[1].innerHTML, subactions: gen_subactions() };
    }
  } else {
    return { type: "done" };
  }
}

function save_current_level() {
  exercises_data[current_exercise].save_data =
    save_level_aux(proof.children[0].children[2].children[0]);
}

// Disgusting way of doing error checking. POSIX does the same so oh well.
let rebuild_level_failed = false;
function rebuild_level_aux(actions) {
  function is_legal_move(expr, move, arg) { // Never trust students
    let legal_moves = [
      "↔-elim-l", "↔-elim-r", "∧-elim-l", "∧-elim-r", "∨-elim", "DNE (classical)", "⊥-elim",
      "→-elim"
    ];

    switch (expr.type) {
      case "Var"  : break;
      case "False": legal_moves += ["¬-elim"]; break;
      case "Not"  : legal_moves += ["¬-intro"]; break;
      case "And"  : legal_moves += ["∧-intro"]; break;
      case "Or"   : legal_moves += ["∨-intro-l", "∨-intro-r"]; break;
      case "Impl" : legal_moves += ["→-intro"]; break;
      case "Iff"  : legal_moves += ["↔-intro"]; break;
    }

    if (!legal_moves.includes(move)) {
      return false;
    }

    if (["↔-elim-l", "↔-elim-r", "∧-elim-l", "∧-elim-r", "→-elim", "¬-elim"].includes(move)) {
      if (!arg) {
        return false;
      } else {
        return true;
      }
    } else if (move === "∨-elim") {
      if (!arg || !arg.type || arg.type != "Or") { // This condition is revolting
        return false;
      } else {
        return true;
      }
    } else {
      return true;
    }
  }

  function rebuild_children() {
    if (actions.subactions.length > 0) {
      let curr = focus;
      rebuild_level_aux(actions.subactions[0]);
      set_focus(curr);
      for (let i = 0; i < actions.subactions.length - 1; i++) {
        curr = focus.parentNode.parentNode.parentNode.children[i+1].children[2].children[0];
        set_focus(curr);
        rebuild_level_aux(actions.subactions[i+1]);
        set_focus(curr);
      }
    }
  }

  if (actions.type == "done" || focus.known) { return; }
  if (
    actions.type
    && !is_legal_move(JSON.parse(focus.getAttribute("data-expr")), actions.type, actions.arg)
  ) {
    rebuild_level_failed = true;
    return;
  }

  let expr = JSON.parse(focus.getAttribute("data-expr"));
  switch (actions.type) {
    case "↔-elim-l":        apply_rule("↔-elim-l", iff_elim_l, JSON.parse(actions.arg)); rebuild_children(); break;
    case "↔-elim-r":        apply_rule("↔-elim-r", iff_elim_r, JSON.parse(actions.arg)); rebuild_children(); break;
    case "∧-elim-l":        apply_rule("∧-elim-l", and_elim_l, JSON.parse(actions.arg)); rebuild_children(); break;
    case "∧-elim-r":        apply_rule("∧-elim-r", and_elim_r, JSON.parse(actions.arg)); rebuild_children(); break;
    case "∨-elim":          apply_rule("∨-elim", or_elim, JSON.parse(actions.arg)); rebuild_children(); break;
    case "DNE (classical)": apply_rule("DNE (classical)", dne); rebuild_children(); break;
    case "⊥-elim":          apply_rule("⊥-elim", false_elim); rebuild_children(); break;
    case "→-elim":          apply_rule("→-elim", impl_elim, JSON.parse(actions.arg)); rebuild_children(); break;
    case "¬-elim":          apply_rule("¬-elim", not_elim, JSON.parse(actions.arg)); rebuild_children(); break;
    case "¬-intro":         apply_rule("¬-intro", not_intro); rebuild_children(); break;
    case "∧-intro":         apply_rule("∧-intro", and_intro); rebuild_children(); break;
    case "∨-intro-l":       apply_rule("∨-intro-l", or_intro_l); rebuild_children(); break;
    case "∨-intro-r":       apply_rule("∨-intro-r", or_intro_r); rebuild_children(); break;
    case "→-intro":         apply_rule("→-intro", impl_intro); rebuild_children(); break;
    case "↔-intro":         apply_rule("↔-intro", iff_intro); rebuild_children(); break;
    case "done": break;
    default: return null;
  }
}

const exercise_style = document.createElement("style");
exercise_style.innerHTML = ".remove-cross { display: none !important; }";
document.head.appendChild(exercise_style);
function setup() {
  const concl = exercises_data[current_exercise].objective;
  const premises = exercises_data[current_exercise].premises;

  proof.children[0].children[2].children[0].innerHTML = tree_to_html(JSON.parse(concl));
  proof.children[0].children[2].children[0].setAttribute("data-expr", concl);
  set_focus(proof.children[0].children[2].children[0]);
  clear_above(focus);

  premises_holder.innerHTML = "";
  for (p of premises) {
    insert_premise(JSON.parse(p));
  }

  if (exercise_mode) {
    change_button.style.display = "none";
    as_premise_button.style.display = "none";
    add_premise_button.style.display = "none";
    exercise_style.disabled = false;
  } else {
    change_button.style.display = "block";
    as_premise_button.style.display = "block";
    add_premise_button.style.display = "flex";
    exercise_style.disabled = true;
  }
}

function rebuild_level(actions) {
  rebuild_level_failed = false;
  setup();
  rebuild_level_aux(actions);
  if (rebuild_level_failed) {
    setup();
  }
  set_focus(proof.children[0].children[2].children[0]);
}

function load_current_level() {
  const data = exercises_data[current_exercise].save_data;
  setup();
  if (data) {
    rebuild_level(data);
  } else {
    setup();
  }
  check_whether_proof_done();
}


// Level panel
var is_level_panel_open = false; // Yay, global state
function open_level_panel() {
  is_level_panel_open = true;
  level_panel.style.display = "block";
  document.documentElement.style.overflow = "hidden";
  document.body.scroll = "no";
  level_panel.focus();
}

function close_level_panel() {
  is_level_panel_open = false;
  level_panel.style.display = "none";
  document.documentElement.style.overflow = "scroll";
  document.body.scroll = "yes";
}

function close_level_panel_click_handler(event, element) {
  if (event.target == element) {
    close_level_panel();
  } else {
    event.stopPropagation();
  }
}

function switch_to_level(n) {
  save_current_level();
  persistent_save();
  current_exercise = n;
  load_current_level();
  close_level_panel();
}


// Persistent data management
function persistent_save() {
  save_current_level();
  let exercises_saves = [];
  let exercises_status = [];
  for (let i = 0; i < exercises_data.length; i++) {
    exercises_saves.push(exercises_data[i].save_data);
    exercises_status.push(level_gallery.children[i].classList.contains("known"));
  }
  localStorage.setItem(
    "persistent_state",
    JSON.stringify({
      version: version, current_exercise: current_exercise, exercises_data: exercises_saves,
      exercises_status: exercises_status,
    })
  );
}
window.addEventListener("beforeunload", () => { persistent_save(); });
window.addEventListener("pagehide", () => { persistent_save(); });

function persistent_clear() { // For manual use only
  const saved = localStorage.removeItem("persistent_state");
}

function persistent_load() {
  const saved = localStorage.getItem("persistent_state");
  if (saved) {
    state = JSON.parse(saved);
    if (state.version === version) {
      current_exercise = state.current_exercise;
      for (let i = 0; i < exercises_data.length; i++) {
        exercises_data[i].save_data = state.exercises_data[i];
        if (state.exercises_status[i]) {
          level_gallery.children[i].classList.add("known");
        }
      }
    }
  }
}


// Import/export
function import_data() {
  // This is all quite silly, but I'm not the one writing the standards
  document.getElementById('file-input').click();
}
document.getElementById('file-input').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    const contents = e.target.result;
    localStorage.setItem("persistent_state", contents);
    persistent_load();
    load_current_level();
  };
  reader.readAsText(file);
});

function export_data() {
  save_current_level();
  persistent_save(); // probably not necessary
  let data = localStorage.getItem("persistent_state");
  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "logic.cool";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}


// Expression input: parsing
const Expression = { // Expression constructors
  EAnd:   (e1, e2) => ({ type: "And", e1, e2 }),
  EOr:    (e1, e2) => ({ type: "Or", e1, e2 }),
  EImpl:  (e1, e2) => ({ type: "Impl", e1, e2 }),
  EIff:   (e1, e2) => ({ type: "Iff", e1, e2 }),
  ENot:   (e)      => ({ type: "Not", e }),
  EFalse: ()       => ({ type: "False" }),
  EVar:   (name)   => ({ type: "Var", name }),
};
const Connective = { AND: "∧", OR: "∨", IMPL: "→", IFF: "↔", NOT: "¬", FALSE: "⊥" };

function tokenize(input) {
  let tokens = [];
  let scratchpad = "";
  let c;
  let failed = false;

  for (let cursor = -1; cursor++, c = input[cursor]; cursor < input.length) {
    if (/[A-Za-z]/.test(c)) {
      scratchpad += c;
    }
    else {
      if (scratchpad.length != 0) {
        tokens.push({ type: 'V', value: scratchpad })
        scratchpad = "";
      }

      if (c == ' ') {} // Skip whitespaces
      else if (c == '(' || c == ')') {
        tokens.push({ type: c })
      }
      else if (Object.values(Connective).includes(c)) {
        tokens.push({ type: c })
      }
      else {
        failed = true;
        break;
      }
    }
  }

  if (failed) {
    return null;
  }

  if (scratchpad.length != 0) {
    tokens.push({ type: 'V', value: scratchpad })
    scratchpad = "";
  }

  return tokens;
}

function parse_input_field() {
  let input = input_panel_field.value;
  let tokens = tokenize(input);
  let pos = 0;

  if (tokens === null) {
    input_panel_error.innerHTML = "Tokenizer error: stop using silly characters";
    return null;
  }

  let peek = () => tokens[pos];
  let consume = (type) => {
    let next = peek();
    if (next && next.type === type) {
      return tokens[pos++];
    } else {
      return null;
    }
  }

  // Grammar:
  // expr := iff
  // iff := impl (↔ impl)
  // impl := or (→ or)
  // or := and (∨ and)
  // and := unary (∧ unary)
  // unary := ¬ unary | VAR | ⊥ | "(" expr ")"

  let parse_expr = () => {
    return parse_iff();
  }

  let parse_binary = (next_call, connective, expression_constructor) => {
    let res = next_call();
    if (!res) {
      return null;
    }
    let next_token = tokens[pos];
    while (next_token && next_token.type === connective) {
      ++pos;
      let arg2 = parse_binary(next_call, connective, expression_constructor);
      // Note the recursion: A ∧ B ∧ C is valid
      if (!arg2) {
        return null;
      }
      res = expression_constructor(res, arg2);
      next_token = tokens[pos];
    }
    return res;
  }

  function parse_iff () { return parse_binary(parse_impl , Connective.IFF , Expression.EIff ); }
  function parse_impl() { return parse_binary(parse_or   , Connective.IMPL, Expression.EImpl); }
  function parse_or  () { return parse_binary(parse_and  , Connective.OR  , Expression.EOr  ); }
  function parse_and () { return parse_binary(parse_unary, Connective.AND , Expression.EAnd ); }

  function parse_unary() {
    let next_token = tokens[pos];
    if (!next_token) {
      return null;
    } else if (next_token.type === Connective.NOT) {
      pos++;
      let arg = parse_unary();
      if (!arg) {
        return null;
      }
      return Expression.ENot(arg); // Implicit negation nesting is supported
    }
    return parse_atom();
  }

  function parse_atom() {
    let next_token = tokens[pos];
    if (!next_token) {
      return null;
    }

    if (next_token.type === 'V') {
      pos++;
      return Expression.EVar(next_token.value);
    } else if (next_token.type === Connective.FALSE) {
      pos++;
      return Expression.EFalse();
    } else if (next_token.type === '(') {
      pos++;
      const e = parse_expr();
      let next_token = tokens[pos];
      if (next_token && next_token.type === ')') {
        pos++;
        return e;
      } else {
        return null;
      }
    }
  }

  let tree = parse_expr(tokens);
  if (tree == null) {
    input_panel_error.innerHTML = "Parser error: show more respect to the grammar";
    return null;
  }
  return tree;
}


// Expression input: input panel management
var is_input_panel_open = false; // Yay, more global state
function open_input_panel(title, callback) {
  input_panel_title.innerHTML = title;
  input_panel_error.innerHTML = " ";
  input_panel_confirm.onclick = function() { callback() };
  is_input_panel_open = true;
  input_panel.style.display = "block";
  document.documentElement.style.overflow = "hidden";
  document.body.scroll = "no";
  input_panel_field.value = "";
  input_panel_field.focus();
}

function insert_special_symbol(symbol) { // Called from the special symbol buttoms
  input_panel_field.setRangeText(symbol.innerHTML);
  input_panel_field.selectionEnd += 1;
  input_panel_field.selectionStart = input_panel_field.selectionEnd;
}

function close_input_panel_click_handler(event, element) {
  if (event.target == element) {
    close_input_panel();
  } else {
    event.stopPropagation();
  }
}

function close_input_panel() {
  is_input_panel_open = false;
  input_panel.style.display = "none";
  document.documentElement.style.overflow = "scroll";
  document.body.scroll = "yes";
}


// Level/input panel: escape to exit and other input niceties
document.onkeydown = function(evt) {
  if (is_input_panel_open && "key" in evt) {
    if (evt.key === "Escape" || evt.key === "Esc") {
      close_input_panel();
    }
    else if (evt.key === "Enter") {
      input_panel_confirm.onclick();
    }
  }
  else if (is_level_panel_open && "key" in evt) {
    if (evt.key === "Escape" || evt.key === "Esc") {
      close_level_panel();
    }
  }
}


// Rules
// Note: we do not draw separators and the tree as neatly as we could. Right now, they a separator
// is always as wide as all the subtrees sitting above it, which is not how things are usually
// done.
function set_separator(name) {
  let sep = focus.parentNode.parentNode.children[1];
  sep.innerHTML = `<div class=sep-bar></div><div class=sep-name>${name}</div>`;
}

function apply_rule(name, rule_function, arg = null) {
  clear_above(focus);
  let expr = JSON.parse(focus.getAttribute("data-expr"));
  rule_function(expr, arg);
  set_separator(name);
  update_status_of_lower_tree(focus);
  set_focus(focus.parentNode.parentNode.children[0].children[0].children[2].children[0]);
  check_whether_proof_done();
}

function apply_rule_with_arg_callback(name, input_callback, additional_verif = null) {
  let parse_res = parse_input_field();
  if (parse_res === null) {
    return;
  }
  if (additional_verif) {
    if (!additional_verif(parse_res)) {
      return;
    }
  }
  close_input_panel();
  apply_rule(name, input_callback, parse_res);
}

function apply_rule_with_arg(name, arg_input_string, input_callback, additional_verif = null) {
  open_input_panel(arg_input_string, () => apply_rule_with_arg_callback(name, input_callback));
}

function validate_or_input(parse_res) {
  switch (parse_res.type) {
    case "Or": return true;
    default  : input_panel_error.innerHTML = "Type error: Or-expression expected"; return false;
  }
}

function is_known(expr, node) { // Used to check whether a branch is done and highlight cause
  // From premisses
  for (let i = 0; i < premises_holder.children.length; i++) {
    let p = premises_holder.children[i];
    if (p.getAttribute("data-expr") === expr) {
      return p;
    }
  }

  // From impl
  p = node.parentNode;
  while (p && p.className === "concl") {
    const attr = JSON.parse(p.children[0].getAttribute("data-expr"));
    if (attr.type === "Impl") {
      if (JSON.stringify(attr.e1) === expr) {
        return p.children[0].children[0];
      }
    }
    p = p.parentNode.parentNode.parentNode.children[2];
  }

  // From RAA
  p = node.parentNode;
  while (p && p.className === "concl") {
    const attr = JSON.parse(p.children[0].getAttribute("data-expr"));
    if (attr.type === "False") {
      const below = p.parentNode.parentNode.parentNode.children[2];
      const sep_name = p.parentNode.parentNode.parentNode.children[1].children[1];
      if (sep_name && sep_name.innerHTML == "⊥-elim") {
        if (below && below.classList.contains("concl")) {
          const below_attr = JSON.parse(below.children[0].getAttribute("data-expr"));
          if (JSON.stringify({"type": "Not", "e": below_attr}) === expr) {
            return below.children[0];
          }
        }
      }
    }
    p = p.parentNode.parentNode.parentNode.children[2];
  }

  return null;
}

function add_hyp(tree) {
  // Would be less ugly with raw HTML embedded
  let new_hyp = document.createElement("div");
  new_hyp.className = "subtree";
  let new_hyp_sep = document.createElement("div");
  new_hyp_sep.className = "sep";
  let new_hyp_hyps = document.createElement("div");
  new_hyp_hyps.className = "hyps";
  let new_hyp_concl = document.createElement("div");
  new_hyp_concl.className = "concl";
  let hyp_expr = document.createElement("div");
  hyp_expr.innerHTML = tree_to_html(tree);
  hyp_expr.className = "expr pseudo-button";
  hyp_expr.onclick = function() { set_focus(this); };
  data_expr = JSON.stringify(tree);
  hyp_expr.setAttribute("data-expr", data_expr);
  new_hyp_concl.appendChild(hyp_expr);
  new_hyp.appendChild(new_hyp_hyps);
  new_hyp.appendChild(new_hyp_sep);
  new_hyp.appendChild(new_hyp_concl);
  focus.parentNode.parentNode.querySelector(".hyps").appendChild(new_hyp);
  let known = is_known(data_expr, focus);
  if (known) {
    hyp_expr.className += " known";
    hyp_expr.known = known;
  }
  return new_hyp;
}

// Called a bit too often, overkill (but performance is not an issue so who cares)
function recheck_status_of_tree(tree) {
  if (tree.known) {
    tree.known.removeAttribute("id");
  }
  let known = is_known(tree.getAttribute("data-expr"), tree);
  if (known) {
    tree.known = known;
    set_focus(tree);
    clear_above(tree);
    tree.classList.add("known");
    return true;
  }
  else {
    tree.known = null;
    tree.classList.remove("known");
  }

  if (!tree.parentNode.parentNode.classList.contains("subtree")) {
    return false;
  }

  let subtrees = tree.parentNode.parentNode.children[0].children;
  let success_for_all = true;
  if (subtrees.length === 0) { return false; }
  for (t of subtrees) {
    if (!recheck_status_of_tree(t.children[2].children[0])) {
      success_for_all = false;
    }
  }
  if (success_for_all) {
    tree.classList.add("known");
  }
  return success_for_all;
}

function impl_intro(expr) { add_hyp(expr.e2); }
function or_intro_l(expr) { add_hyp(expr.e1); }
function or_intro_r(expr) { add_hyp(expr.e2); }
function and_intro(expr) { add_hyp(expr.e1); add_hyp(expr.e2); }
function iff_intro(expr) {
  add_hyp({"type": "Impl", "e1": expr.e1, "e2": expr.e2});
  add_hyp({"type": "Impl", "e1": expr.e2, "e2": expr.e1});
}
function not_intro(expr) { add_hyp({"type": "Impl", "e1": expr.e, "e2": {"type": "False"}}); }
function and_elim_l(expr, arg) { add_hyp({"type": "And", "e1": expr, "e2": arg}); }
function and_elim_r(expr, arg) { add_hyp({"type": "And", "e1": arg, "e2": expr}); }
function or_elim(expr, arg) {
  add_hyp(arg);
  add_hyp({"type": "Impl", "e1": arg.e1, "e2": expr});
  add_hyp({"type": "Impl", "e1": arg.e2, "e2": expr});
}
function iff_elim_l(expr, arg) {
  add_hyp({"type": "Iff", "e1": expr, "e2": arg});
  add_hyp(arg);
}
function iff_elim_r(expr, arg) {
  add_hyp({"type": "Iff", "e1": arg, "e2": expr});
  add_hyp(arg);
}
function false_elim() { add_hyp({"type": "False"}); }
function impl_elim(expr, arg) {
  add_hyp(arg);
  add_hyp({"type": "Impl", "e1": arg, "e2": expr});
}
function dne(expr) {
  add_hyp({"type": "Not", "e": {"type": "Not", "e": expr}});
}
function not_elim(expr, arg) {
  add_hyp(arg);
  add_hyp({"type": "Not", "e": arg});
}


// Focus and highlight management
function highlight_cause(node) {
  let known = node.known;
  if (known) {
    known.id = "known-cause";
  }
}

function set_focus(source) {
  if (focus && focus !== source) {
    let known = focus.known;
    if (known) {
      known.removeAttribute("id");
    }
    focus.removeAttribute("id");
  }

  focus = source;
  focus.setAttribute("id", "focus");
  update_contextual_actions();

  highlight_cause(focus);
}


// Premises management
function recheck_status_of_whole_tree() { // Inserting/removing premises can change everything
  let og_focus = focus;
  recheck_status_of_tree(proof.children[0].children[2].children[0]);
  check_whether_proof_done();
  update_contextual_actions();
  if (og_focus.parentNode) {
    set_focus(og_focus);
  }
}

function insert_premise(premise) {
  var new_premise = document.createElement("div");
  new_premise.className = "expr";
  new_premise.setAttribute("data-expr", JSON.stringify(premise));
  new_premise.innerHTML = tree_to_html(premise);
  append_premise(new_premise);
}

function confirm_input_premise() {
  let parse_res = parse_input_field();
  if (parse_res === null) {
    return;
  }
  close_input_panel();
  insert_premise(parse_res);
}

function add_premise() {
  open_input_panel("New premise:", confirm_input_premise);
}

function remove_premise(premise) {
  premise.parentNode.remove();
  recheck_status_of_whole_tree();
}

function append_premise(premise) {
  var cross = document.createElement("div");
  cross.className = "remove-cross pseudo-button";
  cross.setAttribute("onclick", "remove_premise(this)");
  cross.innerHTML = "x";
  premise.appendChild(cross);
  premises_holder.appendChild(premise);
  recheck_status_of_whole_tree();
}


// Special actions
function clear_above(x) {
  x.parentNode.parentNode.querySelector(".hyps").innerHTML = "";
  x.parentNode.parentNode.querySelector(".sep").innerHTML = "";
  x.classList.remove("known");
}

function apply_clear_above() {
  clear_above(focus);
  recheck_status_of_whole_tree();
}

function apply_as_premise() {
  let clone = focus.cloneNode(true);
  clone.id = "";
  clone.onclick = "";
  clone.className = "expr";
  append_premise(clone);
}

function confirm_change() {
  let parse_res = parse_input_field();
  if (parse_res === null) {
    return;
  }
  close_input_panel();
  focus.innerHTML = tree_to_html(parse_res);
  focus.setAttribute("data-expr", JSON.stringify(parse_res));
  clear_above(focus);
  update_contextual_actions();
  check_whether_proof_done();
}
function apply_change() {
  open_input_panel("New value for node:", confirm_change);
}


// Refresh context
function update_contextual_actions() {
  let impl_intro  = `<div class="rule pseudo-button" onclick='apply_rule("→-intro", impl_intro)'>→-intro</div>`;
  let iff_intro   = `<div class="rule pseudo-button" onclick='apply_rule("↔-intro", iff_intro)'>↔-intro</div>`;
  let and_intro   = `<div class="rule pseudo-button" onclick='apply_rule("∧-intro", and_intro)'>∧-intro</div>`;
  let or_intro_l  = `<div class="rule pseudo-button" onclick='apply_rule("∨-intro-l", or_intro_l)'>∨-intro-l</div>`;
  let or_intro_r  = `<div class="rule pseudo-button" onclick='apply_rule("∨-intro-r", or_intro_r)'>∨-intro-r</div>`;
  let not_intro   = `<div class="rule pseudo-button" onclick='apply_rule("¬-intro", not_intro, "Hypothesis:")'>¬-intro</div>`;
  let not_elim    = `<div class="rule pseudo-button" onclick='apply_rule_with_arg("¬-elim", "Hypothesis:", not_elim)'>¬-elim</div>`;

  if (focus.classList.contains("known")) {
    intro_rules.style.visibility = "hidden";
    elim_rules.style.visibility = "hidden";
    special_rules.style.visibility = "hidden";
    done_message.style.visibility = "visible";
  } else {
    intro_rules.style.visibility = "visible";
    elim_rules.style.visibility = "visible";
    special_rules.style.visibility = "visible";
    done_message.style.visibility = "hidden";
  }

  switch (JSON.parse(focus.getAttribute("data-expr")).type) {
    case "Var"  : intro_rules_holder.innerHTML = ""; break;
    case "False": intro_rules_holder.innerHTML = not_elim; break;
    case "Not"  : intro_rules_holder.innerHTML = not_intro; break;
    case "And"  : intro_rules_holder.innerHTML = and_intro; break;
    case "Or"   : intro_rules_holder.innerHTML = or_intro_l + or_intro_r; break;
    case "Impl" : intro_rules_holder.innerHTML = impl_intro; break;
    case "Iff"  : intro_rules_holder.innerHTML = iff_intro; break;
  }

  if (proof.children[0].children[2].children[0] === focus) {
    change_button.style.visibility = "visible";
  } else {
    change_button.style.visibility = "hidden";
  }
}


// Zooming, drag around
let scale = 1;
proof_top.addEventListener("wheel", (e) => {
  if (!e.ctrlKey) return;
  e.preventDefault();

  const rect = proof_top.getBoundingClientRect();
  const offsetX = e.clientX - rect.left;
  const offsetY = e.clientY - rect.top;
  const x = (offsetX/rect.width) * 100;
  const y = (offsetY/rect.height)*100;

  proof_top.style.transformOrigin = `${x}% ${y}%`;

  const og_scale = scale;
  scale += e.deltaY < 0 ? 0.1 : -0.1;
  scale = Math.min(Math.max(scale, 0.5), 3);
  const scale_ratio = scale/og_scale;

  proof_top.style.transform = `scale(${scale})`;

  proof_top.scrollLeft = (proof_top.scrollLeft + offsetX) * scale_ratio - offsetX;
  proof_top.scrollTop  = (proof_top.scrollTop  + offsetY) * scale_ratio - offsetY;
}, { passive: false });

// From https://stackoverflow.com/a/66313884
let mouseDown = false;
let startX, startY, scrollLeft, ScrollTop;
const slider = drag_box;

const startDragging = (e) => {
  mouseDown = true;
  startX = e.pageX - slider.offsetLeft;
  startY = e.pageY - slider.offsetTop;
  scrollLeft = slider.scrollLeft;
  scrollTop = slider.scrollTop;
}

const stopDragging = (e) => {
  mouseDown = false;
}

const move = (e) => {
  e.preventDefault();
  if (!mouseDown) { return; }
  const x = e.pageX - slider.offsetLeft;
  const scrollX = x - startX;
  slider.scrollLeft = scrollLeft - scrollX;
  const y = e.pageY - slider.offsetTop;
  const scrollY = y - startY;
  slider.scrollTop = scrollTop - scrollY;
}

slider.addEventListener("mousemove", move, false);
slider.addEventListener("mousedown", startDragging, false);
slider.addEventListener("mouseup", stopDragging, false);
slider.addEventListener("mouseleave", stopDragging, false);


// Initialization
function init() {
  populate_level_selector();
  persistent_load();
  load_current_level(); // current_exercise is set by persistent load
}
init();
