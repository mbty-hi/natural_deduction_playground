<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Playground</title>
  <link rel="stylesheet" type="text/css" href="style.css">
  <link rel="shortcut icon" type="image/ico" href="favicon.ico">
</head>

<!-- I hope you like flexboxes and spaghetti code -->

<script>
  // Expression constructors
  const Expression = {
    EAnd:   (e1, e2) => ({ type: "And", e1, e2 }),
    EOr:    (e1, e2) => ({ type: "Or", e1, e2 }),
    EImpl:  (e1, e2) => ({ type: "Impl", e1, e2 }),
    EIff:   (e1, e2) => ({ type: "Iff", e1, e2 }),
    ENot:   (e)      => ({ type: "Not", e }),
    EFalse: ()       => ({ type: "False" }),
    EVar:   (name)   => ({ type: "Var", name }),
  };

  const Connective = { AND: "∧", OR: "∨", IMPL: "→", IFF: "↔", NOT: "¬", FALSE: "⊥" };

  function tokenize(input) {
    let tokens = [];
    let scratchpad = "";
    let c;
    let failed = false;

    for (let cursor = -1; cursor++, c = input[cursor]; cursor < input.length) {
      if (/[A-Za-z]/.test(c)) {
        scratchpad += c;
      }
      else {
        if (scratchpad.length != 0) {
          tokens.push({ type: 'V', value: scratchpad })
          scratchpad = "";
        }

        if (c == ' ') {} // Skip whitespaces
        else if (c == '(' || c == ')') {
          tokens.push({ type: c })
        }
        else if (Object.values(Connective).includes(c)) {
          tokens.push({ type: c })
        }
        else {
          failed = true;
          break;
        }
      }
    }

    if (failed) {
      return null;
    }

    if (scratchpad.length != 0) {
      tokens.push({ type: 'V', value: scratchpad })
      scratchpad = "";
    }

    return tokens;
  }

  function parse_input_field() {
    let input = input_panel_field.value;
    let tokens = tokenize(input);
    let pos = 0;

    if (tokens === null) {
      input_panel_error.innerHTML = "Tokenizer error: stop using silly characters";
      return null;
    }

    let peek = () => tokens[pos];
    let consume = (type) => {
      let next = peek();
      if (next && next.type === type) {
        return tokens[pos++];
      } else {
        return null;
      }
    }

    // Grammar:
    // expr := iff
    // iff := impl (↔ impl)
    // impl := or (→ or)
    // or := and (∨ and)
    // and := unary (∧ unary)
    // unary := ¬ unary | VAR | ⊥ | "(" expr ")"

    let parse_expr = () => {
      return parse_iff();
    }

    let parse_binary = (next_call, connective, expression_constructor) => {
      let res = next_call();
      if (!res) {
        return null;
      }
      let next_token = tokens[pos];
      while (next_token && next_token.type === connective) {
        ++pos;
        let arg2 = parse_binary(next_call, connective, expression_constructor);
        // Note the recursion: A ∧ B ∧ C is valid
        if (!arg2) {
          return null;
        }
        res = expression_constructor(res, arg2);
        next_token = tokens[pos];
      }
      return res;
    }

    function parse_iff () { return parse_binary(parse_impl , Connective.IFF , Expression.EIff ); }
    function parse_impl() { return parse_binary(parse_or   , Connective.IMPL, Expression.EImpl); }
    function parse_or  () { return parse_binary(parse_and  , Connective.OR  , Expression.EOr  ); }
    function parse_and () { return parse_binary(parse_unary, Connective.AND , Expression.EAnd ); }

    function parse_unary() {
      let next_token = tokens[pos];
      if (!next_token) {
        return null;
      } else if (next_token.type === Connective.NOT) {
        pos++;
        let arg = parse_unary();
        if (!arg) {
          return null;
        }
        return Expression.ENot(arg); // Implicit negation nesting is supported
      }
      return parse_atom();
    }

    function parse_atom() {
      let next_token = tokens[pos];
      if (!next_token) {
        return null;
      }

      if (next_token.type === 'V') {
        pos++;
        return Expression.EVar(next_token.value);
      } else if (next_token.type === Connective.FALSE) {
        pos++;
        return Expression.EFalse();
      } else if (next_token.type === '(') {
        pos++;
        const e = parse_expr();
        let next_token = tokens[pos];
        if (next_token && next_token.type === ')') {
          pos++;
          return e;
        } else {
          return null;
        }
      }
    }

    let tree = parse_expr(tokens);
    if (tree == null) {
      input_panel_error.innerHTML = "Parser error: show more respect to the grammar";
      return null;
    }
    return tree;
  }

  function tree_to_expr(tree) {
      function tree_to_expr_aux(tree) {
        switch (tree.type) {
          case "Var"  : return `<div class='expr'>${tree.name}</div>`;
          case "False": return `<div class='expr'>⊥</div>`;
          case "Not"  : return `<div class='expr'> ¬${tree_to_expr_aux(tree.e)} </div>`;
          case "And":
            return `<div class='expr'>${tree_to_expr_aux(tree.e1)} ∧ ${tree_to_expr_aux(tree.e2)}</div>`;
          case "Or":
            return `<div class='expr'>${tree_to_expr_aux(tree.e1)} ∨ ${tree_to_expr_aux(tree.e2)}</div>`;
          case "Impl":
            return `<div class='expr'>${tree_to_expr_aux(tree.e1)} → ${tree_to_expr_aux(tree.e2)}</div>`;
          case "Iff":
            return `<div class='expr'>${tree_to_expr_aux(tree.e1)} ↔ ${tree_to_expr_aux(tree.e2)}</div>`;
          default: return null;
        }
      }

      // First level is not wrapped in an expr node
      switch (tree.type) {
        case "Var"  : return `${tree.name}`;
        case "False": return `⊥`;
        case "Not"  : return ` ¬${tree_to_expr_aux(tree.e)}`;
        case "And"  : return `${tree_to_expr_aux(tree.e1)} ∧ ${tree_to_expr_aux(tree.e2)}`;
        case "Or"   : return `${tree_to_expr_aux(tree.e1)} ∨ ${tree_to_expr_aux(tree.e2)}`;
        case "Impl" : return `${tree_to_expr_aux(tree.e1)} → ${tree_to_expr_aux(tree.e2)}`;
        case "Iff"  : return `${tree_to_expr_aux(tree.e1)} ↔ ${tree_to_expr_aux(tree.e2)}`;
        default: return null;
      }
    }

  function highlight_cause(node) {
    let known = node.known;
    if (known) {
      known.id = "known-cause";
    }
  }

  function set_focus(source) {
    if (focus && focus !== source) {
      let known = focus.known;
      if (known) {
        known.removeAttribute("id");
      }
      focus.removeAttribute("id");
    }

    focus = source;
    focus.setAttribute("id", "focus");
    update_contextual_actions();

    highlight_cause(focus);
  }

  function insert_premise(premise) {
    var new_premise = document.createElement("div");
    new_premise.className = "expr";
    new_premise.setAttribute("data-expr", JSON.stringify(premise));
    new_premise.innerHTML = tree_to_expr(premise);
    append_premise(new_premise);
    recheck_status_of_whole_tree();
  }

  function confirm_input_premise() {
    let parse_res = parse_input_field();
    if (parse_res === null) {
      return;
    }
    close_input_panel();
    insert_premise(parse_res);
  }

  function add_premise() {
    open_input_panel("New premise:", confirm_input_premise);
  }

  function remove_premise(premise) {
    premise.parentNode.remove();
    recheck_status_of_whole_tree();
  }

  var is_level_panel_open = false;
  function open_level_panel() {
    is_level_panel_open = true;
    level_panel.style.display = "block";
    document.documentElement.style.overflow = "hidden";
    document.body.scroll = "no";
    level_panel.focus();
  }

  function close_level_panel() {
    is_level_panel_open = false;
    level_panel.style.display = "none";
    document.documentElement.style.overflow = "scroll";
    document.body.scroll = "yes";
  }

  function close_level_panel_click_handler(event, element) {
    if (event.target == element) {
      close_level_panel();
    } else {
      event.stopPropagation();
    }
  }

  var is_input_panel_open = false;
  function open_input_panel(title, callback) {
    input_panel_title.innerHTML = title;
    input_panel_error.innerHTML = " ";
    input_panel_confirm.onclick = function() { callback() };
    is_input_panel_open = true;
    input_panel.style.display = "block";
    document.documentElement.style.overflow = "hidden";
    document.body.scroll = "no";
    input_panel_field.value = "";
    input_panel_field.focus();
  }

  function close_input_panel_click_handler(event, element) {
    if (event.target == element) {
      close_input_panel();
    } else {
      event.stopPropagation();
    }
  }

  function close_input_panel() {
    is_input_panel_open = false;
    input_panel.style.display = "none";
    document.documentElement.style.overflow = "scroll";
    document.body.scroll = "yes";
  }

  function insert_special_symbol(symbol) {
    input_panel_field.setRangeText(symbol.innerHTML);
    input_panel_field.selectionEnd += 1;
    input_panel_field.selectionStart = input_panel_field.selectionEnd;
  }

  function append_premise(premise) {
    var cross = document.createElement("div");
    cross.className = "remove-cross pseudo-button";
    cross.setAttribute("onclick", "remove_premise(this)");
    cross.innerHTML = "x";
    premise.appendChild(cross);
    premises_holder.appendChild(premise);
  }

  document.onkeydown = function(evt) {
    if (is_input_panel_open && "key" in evt) {
      if (evt.key === "Escape" || evt.key === "Esc") {
        close_input_panel();
      }
      else if (evt.key === "Enter") {
        input_panel_confirm.onclick();
      }
    }
    else if (is_level_panel_open && "key" in evt) {
      if (evt.key === "Escape" || evt.key === "Esc") {
        close_level_panel();
      }
    }
  }

  function update_contextual_actions() {
    let impl_intro  = '<div class="rule pseudo-button" onclick="apply_impl_intro()">→-intro</div>';
    let iff_intro   = '<div class="rule pseudo-button" onclick="apply_iff_intro()">↔-intro</div>';
    let and_intro   = '<div class="rule pseudo-button" onclick="apply_and_intro()">∧-intro</div>';
    let or_intro_l  = '<div class="rule pseudo-button" onclick="apply_or_intro_l()">∨-intro-l</div>';
    let or_intro_r  = '<div class="rule pseudo-button" onclick="apply_or_intro_r()">∨-intro-r</div>';
    let not_intro   = '<div class="rule pseudo-button" onclick="apply_not_intro()">¬-intro</div>';
    let not_elim    = '<div class="rule pseudo-button" onclick="apply_not_elim()">¬-elim</div>';

    if (focus.classList.contains("known")) {
      intro_rules.style.visibility = "hidden";
      elim_rules.style.visibility = "hidden";
      special_rules.style.visibility = "hidden";
      done_message.style.visibility = "visible";
    } else {
      intro_rules.style.visibility = "visible";
      elim_rules.style.visibility = "visible";
      special_rules.style.visibility = "visible";
      done_message.style.visibility = "hidden";
    }

    switch (JSON.parse(focus.getAttribute("data-expr")).type) {
      case "Var"  : intro_rules_holder.innerHTML = ""; break;
      case "False": intro_rules_holder.innerHTML = not_elim; break;
      case "Not"  : intro_rules_holder.innerHTML = not_intro; break;
      case "And"  : intro_rules_holder.innerHTML = and_intro; break;
      case "Or"   : intro_rules_holder.innerHTML = or_intro_l + or_intro_r; break;
      case "Impl" : intro_rules_holder.innerHTML = impl_intro; break;
      case "Iff"  : intro_rules_holder.innerHTML = iff_intro; break;
    }

    if (proof.children[0].children[2].children[0] === focus) {
      change_button.style.visibility = "visible";
    } else {
      change_button.style.visibility = "hidden";
    }
  }

  function clear_above(x) {
    x.parentNode.parentNode.querySelector(".hyps").innerHTML = "";
    x.parentNode.parentNode.querySelector(".sep").innerHTML = "";
    x.classList.remove("known");
  }

  function apply_clear_above() {
    clear_above(focus);
    recheck_status_of_whole_tree();
  }

  function apply_as_premise() {
    let clone = focus.cloneNode(true);
    clone.id = "";
    clone.onclick = "";
    clone.className = "expr";
    append_premise(clone);
    recheck_status_of_whole_tree();
  }

  function is_known(expr, node) {
    // From premisses
    for (let i = 0; i < premises_holder.children.length; i++) {
      let p = premises_holder.children[i];
      if (p.getAttribute("data-expr") === expr) {
        return p;
      }
    }

    // From impl
    p = node.parentNode;
    while (p && p.className === "concl") {
      const attr = JSON.parse(p.children[0].getAttribute("data-expr"));
      if (attr.type === "Impl") {
        if (JSON.stringify(attr.e1) === expr) {
          return p.children[0].children[0];
        }
      }
      p = p.parentNode.parentNode.parentNode.children[2];
    }

    // From RAA
    p = node.parentNode;
    while (p && p.className === "concl") {
      const attr = JSON.parse(p.children[0].getAttribute("data-expr"));
      if (attr.type === "False") {
        const below = p.parentNode.parentNode.parentNode.children[2];
        const sep_name = p.parentNode.parentNode.parentNode.children[1].children[1];
        if (sep_name && sep_name.innerHTML == "⊥-elim") {
          if (below && below.classList.contains("concl")) {
            const below_attr = JSON.parse(below.children[0].getAttribute("data-expr"));
            if (JSON.stringify({"type": "Not", "e": below_attr}) === expr) {
              return below.children[0];
            }
          }
        }
      }
      p = p.parentNode.parentNode.parentNode.children[2];
    }

    return null;
  }

  // Would be less ugly with raw HTML embedded.
  function add_hyp(tree) {
    let new_hyp = document.createElement("div");
    new_hyp.className = "subtree";
    let new_hyp_sep = document.createElement("div");
    new_hyp_sep.className = "sep";
    let new_hyp_hyps = document.createElement("div");
    new_hyp_hyps.className = "hyps";
    let new_hyp_concl = document.createElement("div");
    new_hyp_concl.className = "concl";
    let hyp_expr = document.createElement("div");
    hyp_expr.innerHTML = tree_to_expr(tree);
    hyp_expr.className = "expr pseudo-button";
    hyp_expr.onclick = function() { set_focus(this); };
    data_expr = JSON.stringify(tree);
    hyp_expr.setAttribute("data-expr", data_expr);
    new_hyp_concl.appendChild(hyp_expr);
    new_hyp.appendChild(new_hyp_hyps);
    new_hyp.appendChild(new_hyp_sep);
    new_hyp.appendChild(new_hyp_concl);
    focus.parentNode.parentNode.querySelector(".hyps").appendChild(new_hyp);
    let known = is_known(data_expr, focus);
    if (known) {
      hyp_expr.className += " known";
      hyp_expr.known = known;
    }
    return new_hyp;
  }

  // Called a bit too often, overkill (but performance is not an issue so who cares)
  function recheck_status_of_tree(tree) {
    if (tree.known) {
      tree.known.removeAttribute("id");
    }
    let known = is_known(tree.getAttribute("data-expr"), tree);
    if (known) {
      tree.known = known;
      set_focus(tree);
      clear_above(tree);
      tree.classList.add("known");
      return true;
    }
    else {
      tree.known = null;
      tree.classList.remove("known");
    }

    if (!tree.parentNode.parentNode.classList.contains("subtree")) {
      return false;
    }

    let subtrees = tree.parentNode.parentNode.children[0].children;
    let success_for_all = true;
    if (subtrees.length === 0) { return false; }
    for (t of subtrees) {
      if (!recheck_status_of_tree(t.children[2].children[0])) {
        success_for_all = false;
      }
    }
    if (success_for_all) {
      tree.classList.add("known");
    }
    return success_for_all;
  }

  function recheck_status_of_whole_tree() {
    let og_focus = focus;
    recheck_status_of_tree(proof.children[0].children[2].children[0]);
    check_whether_proof_done();
    update_contextual_actions();
    if (og_focus.parentNode) {
      set_focus(og_focus);
    }
  }

  function check_whether_proof_done() {
    if (proof.children[0].children[2].children[0].classList.contains("known")) {
      drag_box.classList.add("known");
      level_gallery.children[current_exercise].classList.add("known");
    } else {
      drag_box.classList.remove("known");
      level_gallery.children[current_exercise].classList.remove("known");
    }
  }

  function clear_status_of_lower_tree(level) {
    if (level.classList.contains("expr")) {
      level.classList.remove("known");
      if (level.parentNode.parentNode.parentNode.parentNode.id != "proof-top") {
        clear_status_of_lower_tree(
          level.parentNode.parentNode.parentNode.parentNode.children[2].children[0]
        );
      }
    }
  }

  function update_status_of_lower_tree(level) {
    function are_all_immediately_above_known(level) {
      let above_hyps = level.parentNode.parentNode.children[0];
      if (above_hyps) {
        for (h of above_hyps.children) {
          if (!h.children[2].children[0].classList.contains("known")) {
            return false;
          }
        }
        return true;
      }
    }

    if (level.classList.contains("expr") && are_all_immediately_above_known(level)) {
      level.classList.add("known");
      if (level.parentNode.parentNode.parentNode.parentNode.id != "proof-top") {
        update_status_of_lower_tree(
          level.parentNode.parentNode.parentNode.parentNode.children[2].children[0]
        );
      }
    }
  }

  // Note: we do not draw separators and the tree as neatly as we could. Right now, they a separator
  // is always as wide as all the subtrees sitting above it, which is not how things are usually
  // done.
  function set_separator(name) {
    let sep = focus.parentNode.parentNode.children[1];
    sep.innerHTML = `<div class=sep-bar></div><div class=sep-name>${name}</div>`;
  }

  // All of these apply_XXX functions share common parts and could be refactored.
  function apply_impl_intro() {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let new_hyp = add_hyp(expr_object.e2);
    set_separator("→-intro");
    update_status_of_lower_tree(focus);
    set_focus(new_hyp.children[2].children[0]);
    check_whether_proof_done();
  }

  function apply_or_intro_l() {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let new_hyp = add_hyp(expr_object.e1);
    set_separator("∨-intro-l");
    update_status_of_lower_tree(focus);
    set_focus(new_hyp.children[2].children[0]);
    check_whether_proof_done();
  }

  function apply_or_intro_r() {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let new_hyp = add_hyp(expr_object.e2);
    set_separator("∨-intro-r");
    update_status_of_lower_tree(focus);
    set_focus(new_hyp.children[2].children[0]);
    check_whether_proof_done();
  }

  function apply_and_intro() {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp(expr_object.e1);
    add_hyp(expr_object.e2);
    set_separator("∧-intro");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }

  function apply_iff_intro() {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp({"type": "Impl", "e1": expr_object.e1, "e2": expr_object.e2});
    add_hyp({"type": "Impl", "e1": expr_object.e2, "e2": expr_object.e1});
    set_separator("↔-intro");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }

  function apply_not_intro() {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp({"type": "Impl", "e1": expr_object.e, "e2": {"type": "False"}});
    set_separator("¬-intro");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }

  function confirm_other_branch_input(callback) {
    clear_above(focus);
    let parse_res = parse_input_field();
    if (parse_res === null) {
      return;
    }
    close_input_panel();
    callback(parse_res);
  }

  function apply_and_elim_l_aux(other_branch) {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp({"type": "And", "e1": expr_object, "e2": other_branch});
    set_separator("∧-elim-l");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }
  function apply_and_elim_l() {
    open_input_panel(
      "Right branch of the and:",
      () => confirm_other_branch_input(apply_and_elim_l_aux)
    );
  }

  function apply_and_elim_r_aux(other_branch) {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp({"type": "And", "e1": other_branch, "e2": expr_object});
    set_separator("∧-elim-r");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }
  function apply_and_elim_r() {
    open_input_panel(
      "Left branch of the and:",
      () => confirm_other_branch_input(apply_and_elim_r_aux)
    );
  }

  function confirm_or_input() {
    let parse_res = parse_input_field();
    if (parse_res === null) {
      return;
    }
    switch (parse_res.type) {
      case "Or": close_input_panel(); apply_or_elim_aux(parse_res); break;
      default  : input_panel_error.innerHTML = "Type error: Or-expression expected";
    }
  }
  function apply_or_elim_aux(or) {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp(or);
    add_hyp({"type": "Impl", "e1": or.e1, "e2": expr_object});
    add_hyp({"type": "Impl", "e1": or.e2, "e2": expr_object});
    set_separator("∨-elim");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }
  function apply_or_elim() {
    open_input_panel("Or hypothesis:", () => confirm_or_input());
  }

  function apply_iff_elim_l_aux(other_branch) {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp({"type": "Iff", "e1": expr_object, "e2": other_branch});
    add_hyp(other_branch);
    set_separator("↔-elim-l");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }
  function apply_iff_elim_l() {
    open_input_panel(
      "Right branch of the iff:",
      () => confirm_other_branch_input(apply_iff_elim_l_aux)
    );
  }

  function apply_iff_elim_r_aux(other_branch) {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp({"type": "Iff", "e1": other_branch, "e2": expr_object});
    add_hyp(other_branch);
    set_separator("↔-elim-r");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }
  function apply_iff_elim_r() {
    open_input_panel(
      "Left branch of the iff:",
      () => confirm_other_branch_input(apply_iff_elim_r_aux)
    );
  }

  function apply_false_elim() {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp({"type": "False"});
    set_separator("⊥-elim");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }

  function apply_impl_elim_aux(other_branch) {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp(other_branch);
    add_hyp({"type": "Impl", "e1": other_branch, "e2": expr_object});
    set_separator("→-elim");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }
  function apply_impl_elim() {
    open_input_panel(
      "Implication condition:",
      () => confirm_other_branch_input(apply_impl_elim_aux)
    );
  }

  function apply_dne() {
    clear_above(focus);
    let expr_object = JSON.parse(focus.getAttribute("data-expr"));
    let l_hyp = add_hyp({"type": "Not", "e": {"type": "Not", "e": expr_object}});
    set_separator("DNE (classical)");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }

  function apply_not_elim_aux(hyp) {
    clear_above(focus);
    let l_hyp = add_hyp(hyp);
    add_hyp({"type": "Not", "e": hyp});
    set_separator("¬-elim");
    update_status_of_lower_tree(focus);
    set_focus(l_hyp.children[2].children[0]);
    check_whether_proof_done();
  }
  function apply_not_elim() {
    open_input_panel(
      "On proposition:",
      () => confirm_other_branch_input(apply_not_elim_aux)
    );
  }

  function confirm_change() {
    let parse_res = parse_input_field();
    if (parse_res === null) {
      return;
    }
    close_input_panel();
    focus.innerHTML = tree_to_expr(parse_res);
    focus.setAttribute("data-expr", JSON.stringify(parse_res));
    clear_above(focus);
    update_contextual_actions();
    check_whether_proof_done();
  }

  function apply_change() {
    open_input_panel("New value for node:", confirm_change);
  }
</script>

<body>
<input type="file" id="file-input" style="display: none;"/>
<div
  id=content
  style="min-height: 100%; display:flex; flex-direction: column; margin-bottom: 10px;"
>
  <h1 style="margin-bottom: 0">Natural deduction playground</h1>
  <p class=center>
  Fun for the whole family
  </p>

  <div
    class=box
    style="
      display: flex; gap: 1em; justify-content: space-around; margin-top: 1.2em;
      flex-wrap: wrap;"
  >
    <div class="action pseudo-button" onclick="open_level_panel()">Select exercise</div>
    <div style="display: flex; flex-direction: row; gap: 2em;">
      <div class="action pseudo-button" onclick="import_data()">Import</div>
      <div class="action pseudo-button" onclick="export_data()">Export</div>
    </div>
  </div>

  <div
    id=level-panel style="display: none;"
    onclick="close_level_panel_click_handler(event, this)"
  >
    <div
      style="font-size: 200%; position: absolute; top: 20px; right: 20px; cursor: pointer;"
      onclick="close_level_panel()">&times;
    </div>

    <div
      class=gallery id=level-gallery style="max-width: 940px; padding: 20px; margin: auto;"
      onclick="close_level_panel_click_handler(event, this)"
    >
    </div>
  </div>

  <div id=input-panel style="display: none;" onclick="close_input_panel_click_handler(event, this)">
    <div
      style="font-size: 200%; position: absolute; top: 20px; right: 20px; cursor: pointer;"
      onclick="close_input_panel()">&times;
    </div>
    <div
      style="
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        height: 100%; gap: .5em;
      "
      onclick="close_input_panel_click_handler(event, this)"
    >
      <div
        id=input-panel-title
        style="
          margin: 15px; margin-bottom: 0; font-size: 200%; font-weight: bold; text-align: center;
        "
      ></div>
      <div id=input-panel-error-message style="color: var(--red); min-height: 1.5em;"></div>
      <input
        type=text id=input-panel-field
        style="
          margin: 15px; margin-bottom: 2px; font-size: 200%; font-weight: bold; text-align: center;
          border-radius: 6px;
        "
      ></input>
      <div
        class=rules style="display: flex; flex-wrap: wrap; width: fit-content;"
        onmousedown="event.preventDefault()"
      >
        <div
          class="rule-s pseudo-button"
          onmousedown="event.preventDefault()" onclick="insert_special_symbol(this)">&#x2227;</div>
        <div
          class="rule-s pseudo-button"
          onmousedown="event.preventDefault()" onclick="insert_special_symbol(this)">&#x2228;</div>
        <div
          class="rule-s pseudo-button"
          onmousedown="event.preventDefault()" onclick="insert_special_symbol(this)">&#x2194;</div>
        <div
          class="rule-s pseudo-button"
          onmousedown="event.preventDefault()" onclick="insert_special_symbol(this)">&#xAC;</div>
        <div
          class="rule-s pseudo-button"
          onmousedown="event.preventDefault()" onclick="insert_special_symbol(this)">&#x22A5;</div>
        <div
          class="rule-s pseudo-button"
          onmousedown="event.preventDefault()" onclick="insert_special_symbol(this)">&#x2192;</div>
      </div>
      <div
        id=input-panel-confirm class=pseudo-button
        style="
          background-color: var(--level-b); font-size: large; padding: 10px;
          border: 3px solid var(--black); border-radius: 10px;
        "
        onmousedown="event.preventDefault()"
      >
        Confirm
      </div>
    </div>
  </div>

  <div
    id=premises-mgmt-box class=box
    style="background-color: var(--level-c); margin: 15px 0 15px 0; display: flex;
           flex-direction: row; align-items: center; gap: 10px; flex-wrap: wrap;"
  >
    <span>Premises:</span>
    <div
      style="display: inline-flex; flex-direction: row; align-items: center; gap: 5px;
             flex-wrap: wrap;">
      <div id=premises style="display: inline-flex; gap: 5px; width: fit-content; flex-wrap: wrap;">
      </div>
      <div
        id="add-premise-button" class="expr pseudo-button" onclick="add_premise()"
        style="
          background-color: var(--lgreen);
          color: color-mix(in srgb, hsl(120 30% 50%), hsl(240 10% 35%) 30%);
          border-color: color-mix(in srgb, hsl(120 30% 50%), hsl(240 10% 17%) 30%);
          border-radius: 10px;
          height: 38px;
          padding: 0 10px;"
      >+</div>
    </div>
  </div>

  <div
    id=playground
    style="display: flex; flex-direction: row; justify-content: space-between;
           width: 100%; gap: 15px; margin-bottom: 10px; flex-wrap: wrap; height: 100%;
           flex: 1 1 auto;"
  >
    <div
      id="drag-box" class=box
      style="overflow: auto; flex-grow: 1; min-width: 55%; justify-content: flex-end();"
    >
    <div
      id="proof-top"
      style="display: flex; justify-content: center; align-items: flex-end; min-width: fit-content;
             height: 100%;"
    >
    <div
      id=proof
      style="text-align: center; align-items: center; display: flex; flex-direction: column;
             justify-content: flex-end; overflow: auto; user-select: none;"
    >
      <div class="subtree" style="padding: 10px;">
        <div class="hyps"></div>
        <div class="sep"></div>
        <div class="concl">
          <div
            id="focus"
            class="expr pseudo-button" onclick="set_focus(this)"
            data-expr='{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Or","e1":{"type":"Var","name":"B"},"e2":{"type":"Var","name":"C"}}}'
          >
            <div class=expr>A</div>
            &#x2192;
            <div class=expr>
              <div class=expr>B</div>
              &#x2228;
              <div class=expr>C</div>
            </div>
          </div>
        </div>
      </div>
      </div>
      </div>
    </div>

    <div id=actions-box class=box
         style="display: flex; flex-direction: column; align-items: center;
                gap: 10px; justify-content: flex-start; flex-basis: 35%; flex-grow: 1;"
    >
      <div id=done-message style="color: var(--green); font-size: x-large; visibility: hidden;">
        Branch done
      </div>

      <div class=rules-box id=intro-rules>
        Intro rules:
        <div class=rules id=intro-rules-holder style="display: flex; height: 3em;">
          <div class="rule pseudo-button" onclick="apply_impl_intro()">&#x2192;-intro</div>
        </div>
      </div>

      <div class=rules-box id=elim-rules>
        Elim rules:
        <div class=rules style="display: flex; flex-wrap: wrap; width: fit-content;">
          <div class="rule pseudo-button" onclick="apply_iff_elim_l()">&#x2194;-elim-l</div>
          <div class="rule pseudo-button" onclick="apply_iff_elim_r()">&#x2194;-elim-r</div>
          <div class="rule pseudo-button" onclick="apply_and_elim_l()">&#x2227;-elim-l</div>
          <div class="rule pseudo-button" onclick="apply_and_elim_r()">&#x2227;-elim-r</div>
          <div class="rule pseudo-button" onclick="apply_or_elim()">&#x2228;-elim</div>
          <div class="rule pseudo-button" onclick="apply_dne()">DNE</div>
          <div class="rule pseudo-button" onclick="apply_false_elim()">&#x22A5;-elim</div>
          <div class="rule pseudo-button" onclick="apply_impl_elim()">&#x2192;-elim</div>
        </div>
      </div>

      <div class=rules-box id=special-rules>
        Special:
        <div class=rules style="display: flex; flex-wrap: wrap; width: fit-content;">
          <div class="rule pseudo-button" onclick="apply_clear_above()">clear above</div>
          <div id="as-premise-button" class="rule pseudo-button" onclick="apply_as_premise()">as premise</div>
          <div id="change-button" class="rule pseudo-button" onclick="apply_change()">change</div>
        </div>
      </div>
    </div>
  </div>
</div>
</body>

<style>
  .box {
    border: 4px solid var(--black);
    border-radius: 10px;
    background-color: var(--level-c);
    padding: 10px;
  }

  .action {
    outline: 3px solid var(--black);
    border-radius: 10px;
    background-color: var(--level-b);
    padding: 5px;
    text-align: center;
  }

  .rule, .rule-s {
    outline: 3px solid var(--black);
    border-radius: 10px;
    background-color: var(--level-b);
    padding: 5px;
    width: 6em;
    text-align: left;
    margin: 10px;
  }
  .rule-s {
    width: 2em;
    text-align: center;
    font-size: large;
  }

  .rules {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 0 .2em;
  }

  .rules-box {
    text-align: center;
  }

  .expr {
    border: 2px solid var(--black);
    border-radius: 10px;
    background-color: var(--level-a);
    padding: 3px;
    display: inline-flex;
    align-items: center;
    height: fit-content;
  }

  .expr > .expr {
    color: var(--ghost);
  }

  .concl > .expr, #premises > .expr, .hyps > .expr {
    padding: 0 20px;
    height: 38px;
    display: inline-flex;
    align-items: center;
    gap: 10px;
    overflow: hidden;
  }
  .subtree > .expr {
    margin: 0 20px;
  }

  .subtree, .hyps {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .hyps {
    gap: 20px;
  }

  .hyps {
    align-items: flex-end;
    flex-direction: row;
  }

  .sep {
    gap: 3px;
    margin: 6px 0;
    padding: 0 6px;
    width: 100%;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    background-color: var(--black);
    border-radius: 6px;
    max-height: .6em;
  }

  .sep-bar {
    max-height: 4px;
    border-radius: 4px;
    flex: 1;
  }

  .sep-name {
    font-size: x-small;
    width: fit-content;
    color: var(--ghost);
    font-weight: bold;
  }

  #focus {
    filter: none !important;
    cursor: initial !important;
    outline: 4px solid var(--lblue);
  }

  .remove-cross {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background-color: var(--lred);
    border: 2px solid var(--red);
    border-radius: 50%;
    color: var(--red);
    width: 1em; height: 1em;
    font-size: small;
  }

  #input-panel {
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    height: 100%;
    background-color: hsla(240, 10%, 5%, 0.8);
    color: var(--white);
    z-index: 1;
    padding: 25px;
    overflow-y: scroll;
    overflow-x: hidden;
  }

  #level-panel {
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    height: 100%;
    background-color: hsla(240, 10%, 5%, 0.8);
    color: var(--white);
    z-index: 1;
    padding: 25px;
    overflow-y: scroll;
    overflow-x: hidden;
  }

  .subtree {
    display: flex;
    flex-direction: column;
  }

  #input-panel-title {
    font-size: x-large;
  }

  #input-panel-field {
    max-width: 90%;
    background-color: var(--black);
    border: 2px solid var(--level-a);
    color: var(--white);
  }
  #input-panel-field:focus {
    outline: 2px solid var(--white);
  }

  .pseudo-button:hover {
    filter: brightness(1.4);
    cursor: pointer;
  }

  .gallery-item {
    background-color: var(--level-a);
    border: 4px solid var(--black);
  }

  .gallery-i-wish-i-didnt-have-to-resort-to-this-dirty-hack {
    width: 204px;
  }

  .gallery-item:hover {
    cursor: pointer;
  }

  .known {
    background-color: color-mix(in srgb, hsl(120 30% 50%), hsl(240 10% 35%) 50%) !important;
  }

  #known-cause {
    background-color: color-mix(in srgb, hsl(60  50% 70%), hsl(240 10% 35%) 50%) !important;
  }
</style>

<script>
  var proof               = document.getElementById("proof");
  var proof_top           = document.getElementById("proof-top");
  var premises_holder     = document.getElementById("premises");
  var input_panel         = document.getElementById("input-panel");
  var input_panel_title   = document.getElementById("input-panel-title");
  var input_panel_field   = document.getElementById("input-panel-field");
  var input_panel_confirm = document.getElementById("input-panel-confirm");
  var input_panel_error   = document.getElementById("input-panel-error-message");
  var intro_rules_holder  = document.getElementById("intro-rules-holder");
  var level_panel         = document.getElementById("level-panel");
  var focus               = document.getElementById("focus");
  var drag_box            = document.getElementById("drag-box");
  var intro_rules         = document.getElementById("intro-rules");
  var elim_rules          = document.getElementById("elim-rules");
  var special_rules       = document.getElementById("special-rules");
  var done_message        = document.getElementById("done-message");
  var change_button       = document.getElementById("change-button");
  var as_premise_button   = document.getElementById("as-premise-button");
  var add_premise_button  = document.getElementById("add-premise-button");
  var level_gallery       = document.getElementById("level-gallery");

  const exercise_1 =
    '{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Or","e1":{"type":"Var","name":"B"},"e2":{"type":"Var","name":"C"}}}';
  const premises_1 = [
    '{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Var","name":"B"}}',
  ];
  const exercise_2 = '{"type":"Var","name":"B"}';
  const premises_2 = [
    '{"type":"Not","e":{"type":"Var","name":"C"}}',
    '{"type":"Impl","e1":{"type":"Not","e":{"type":"Var","name":"B"}},"e2":{"type":"Var","name":"C"}}',
  ];
  const exercise_3 =
    '{"type":"Iff","e1":{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Var","name":"B"}},"e2":{"type":"Impl","e1":{"type":"Not","e":{"type":"Var","name":"B"}},"e2":{"type":"Not","e":{"type":"Var","name":"A"}}}}';
  const exercise_4 =
    '{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Impl","e1":{"type":"Var","name":"B"},"e2":{"type":"Var","name":"A"}}}';
  const exercise_5 =
    '{"type":"Impl","e1":{"type":"Impl","e1":{"type":"Var","name":"A"},"e2":{"type":"Not","e":{"type":"Var","name":"A"}}},"e2":{"type":"Not","e":{"type":"Var","name":"A"}}}';
  const exercise_6 = '{"type":"Impl","e1":{"type":"False"},"e2":{"type":"Var","name":"A"}}';
  const exercise_7 = '{"type":"Not","e":{"type":"And","e1":{"type":"Not","e":{"type":"Var","name":"A"}},"e2":{"type":"Var","name":"B"}}}';
  const premises_7 = ['{"type":"Var","name":"A"}'];

  function make_exercise(objective, premises) {
    return {objective: objective, premises: premises, save_data: null};
  }

  var exercises_data = [
    make_exercise(exercise_4, []), make_exercise(exercise_6, []),
    make_exercise(exercise_1, premises_1), make_exercise(exercise_2, premises_2),
    make_exercise(exercise_7, premises_7),
    make_exercise(exercise_5, []),
    make_exercise(exercise_3, []),
  ];

  const exercise_style = document.createElement("style");
  exercise_style.innerHTML = ".remove-cross { display: none !important; }";
  document.head.appendChild(exercise_style);

  function setup() {
    const concl = exercises_data[current_exercise].objective;
    const premises = exercises_data[current_exercise].premises;

    proof.children[0].children[2].children[0].innerHTML = tree_to_expr(JSON.parse(concl));
    proof.children[0].children[2].children[0].setAttribute("data-expr", concl);
    set_focus(proof.children[0].children[2].children[0]);
    clear_above(focus);

    premises_holder.innerHTML = "";
    for (p of premises) {
      insert_premise(JSON.parse(p));
    }

    if (exercise_mode) {
      change_button.style.display = "none";
      as_premise_button.style.display = "none";
      add_premise_button.style.display = "none";
      exercise_style.disabled = false;
    } else {
      change_button.style.display = "block";
      as_premise_button.style.display = "block";
      add_premise_button.style.display = "flex";
      exercise_style.disabled = true;
    }
  }

  let scale = 1;
  proof_top.addEventListener("wheel", (e) => {
    if (!e.ctrlKey) return;
    e.preventDefault();

    const rect = proof_top.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;
    const x = (offsetX/rect.width) * 100;
    const y = (offsetY/rect.height)*100;

    proof_top.style.transformOrigin = `${x}% ${y}%`;

    const og_scale = scale;
    scale += e.deltaY < 0 ? 0.1 : -0.1;
    scale = Math.min(Math.max(scale, 0.5), 3);
    const scale_ratio = scale/og_scale;

    proof_top.style.transform = `scale(${scale})`;

    proof_top.scrollLeft = (proof_top.scrollLeft + offsetX) * scale_ratio - offsetX;
    proof_top.scrollTop  = (proof_top.scrollTop  + offsetY) * scale_ratio - offsetY;
  }, { passive: false });

  // From https://stackoverflow.com/a/66313884
  let mouseDown = false;
  let startX, startY, scrollLeft, ScrollTop;
  const slider = drag_box;

  const startDragging = (e) => {
    mouseDown = true;
    startX = e.pageX - slider.offsetLeft;
    startY = e.pageY - slider.offsetTop;
    scrollLeft = slider.scrollLeft;
    scrollTop = slider.scrollTop;
  }

  const stopDragging = (e) => {
    mouseDown = false;
  }

  const move = (e) => {
    e.preventDefault();
    if (!mouseDown) { return; }
    const x = e.pageX - slider.offsetLeft;
    const scrollX = x - startX;
    slider.scrollLeft = scrollLeft - scrollX;
    const y = e.pageY - slider.offsetTop;
    const scrollY = y - startY;
    slider.scrollTop = scrollTop - scrollY;
  }

  function is_legal_move(expr, move, arg) {
    let legal_moves = [
      "↔-elim-l", "↔-elim-r", "∧-elim-l", "∧-elim-r", "∨-elim", "DNE (classical)", "⊥-elim",
      "→-elim"
    ];

    switch (expr.type) {
      case "Var"  : break;
      case "False": legal_moves += ["¬-elim"]; break;
      case "Not"  : legal_moves += ["¬-intro"]; break;
      case "And"  : legal_moves += ["∧-intro"]; break;
      case "Or"   : legal_moves += ["∨-intro-l", "∨-intro-r"]; break;
      case "Impl" : legal_moves += ["→-intro"]; break;
      case "Iff"  : legal_moves += ["↔-intro"]; break;
    }

    if (!legal_moves.includes(move)) {
      return false;
    }

    if (["↔-elim-l", "↔-elim-r", "∧-elim-l", "∧-elim-r", "→-elim", "¬-elim"].includes(move)) {
      if (!arg) {
        return false;
      } else {
        return true;
      }
    } else if (move === "∨-elim") {
      if (!arg || !arg.type || arg.type != "Or") {
        return false;
      } else {
        return true;
      }
    }

    return true;
  }

  let rebuild_level_failed = false; // Disgusting way of doing error checking. Oh well.
  function rebuild_level_aux(actions) {
    if (actions.type == "done" || focus.known) { return; }

    if (actions.type) {
      if (!is_legal_move(JSON.parse(focus.getAttribute("data-expr")), actions.type, actions.arg)) {
        rebuild_level_failed = true;
        return;
      }
    }

    function rebuild_children() {
      if (actions.subactions.length > 0) {
        let curr = focus;
        rebuild_level_aux(actions.subactions[0]);
        set_focus(curr);
        for (let i = 0; i < actions.subactions.length - 1; i++) {
          curr = focus.parentNode.parentNode.parentNode.children[i+1].children[2].children[0];
          set_focus(curr);
          rebuild_level_aux(actions.subactions[i+1]);
          set_focus(curr);
        }
      }
    }

    switch (actions.type) {
      case "↔-elim-l"  : apply_iff_elim_l_aux(JSON.parse(actions.arg)); rebuild_children(); break;
      case "↔-elim-r"  : apply_iff_elim_r_aux(JSON.parse(actions.arg)); rebuild_children(); break;
      case "∧-elim-l"  : apply_and_elim_l_aux(JSON.parse(actions.arg)); rebuild_children(); break;
      case "∧-elim-r"  : apply_and_elim_r_aux(JSON.parse(actions.arg)); rebuild_children(); break;
      case "∨-elim"    : apply_or_elim_aux(JSON.parse(actions.arg)); rebuild_children(); break;
      case "DNE (classical)": apply_dne(); rebuild_children(); break;
      case "⊥-elim"    : apply_false_elim(); rebuild_children(); break;
      case "→-elim"    : apply_impl_elim_aux(JSON.parse(actions.arg)); rebuild_children(); break;
      case "¬-elim"    : apply_not_elim_aux(JSON.parse(actions.arg)); rebuild_children(); break;
      case "¬-intro"   : apply_not_intro(); rebuild_children(); break;
      case "∧-intro"   : apply_and_intro(); rebuild_children(); break;
      case "∨-intro-l" : apply_or_intro_l(); rebuild_children(); break;
      case "∨-intro-r" : apply_or_intro_r(); rebuild_children(); break;
      case "→-intro"   : apply_impl_intro(); rebuild_children(); break;
      case "↔-intro"   : apply_iff_intro(); rebuild_children(); break;
      case "done"      : break;
      default          : return null;
    }
  }

  function rebuild_level(actions) {
    rebuild_level_failed = false;
    setup();
    rebuild_level_aux(actions);
    if (rebuild_level_failed) {
      setup();
    }
    set_focus(proof.children[0].children[2].children[0]);
  }

  function save_level_aux(node) {
    let sep = node.parentNode.parentNode.children[1];
    let above = node.parentNode.parentNode.children[0];

    function get_nth_above_child_expr(n) {
      return above.children[n].children[2].children[0].getAttribute("data-expr");
    }

    function gen_subactions() {
      let subactions = [];
      for (c of above.children) {
        subactions.push(save_level_aux(c.children[2].children[0]));
      }
      return subactions;
    }

    if (sep.innerHTML != "") {
      switch (sep.children[1].innerHTML) {
        case "↔-elim-l":""
          return {
            type: sep.children[1].innerHTML,
            arg: get_nth_above_child_expr(1),
            subactions: gen_subactions(),
          };
        case "↔-elim-r":
          return {
            type: sep.children[1].innerHTML,
            arg: get_nth_above_child_expr(1),
            subactions: gen_subactions(),
          };
        case "∧-elim-l":
          return {
            type: sep.children[1].innerHTML,
            arg: JSON.stringify(JSON.parse(get_nth_above_child_expr(0)).e2),
            subactions: gen_subactions(),
          };
        case "∧-elim-r":
          return {
            type: sep.children[1].innerHTML,
            arg: JSON.stringify(JSON.parse(get_nth_above_child_expr(0)).e1),
            subactions: gen_subactions(),
          };
        case "∨-elim":
          return {
            type: sep.children[1].innerHTML,
            arg: get_nth_above_child_expr(0),
            subactions: gen_subactions(),
          };
        case "DNE (classical)":
          return {
            type: sep.children[1].innerHTML,
            subactions: gen_subactions(),
          };
        case "⊥-elim":
          return {
            type: sep.children[1].innerHTML,
            subactions: gen_subactions()
          };
        case "→-elim":
          return {
            type: sep.children[1].innerHTML,
            arg: get_nth_above_child_expr(0),
            subactions: gen_subactions()
          };
        case "¬-elim":
          return {
            type: sep.children[1].innerHTML,
            arg: get_nth_above_child_expr(0),
            subactions: gen_subactions()
          };
        case "¬-intro":
          return {
            type: sep.children[1].innerHTML,
            subactions: gen_subactions()
          };
        case "∧-intro":
          return {
            type: sep.children[1].innerHTML,
            subactions: gen_subactions()
          };
        case "∨-intro-l":
          return {
            type: sep.children[1].innerHTML,
            subactions: gen_subactions()
          };
        case "∨-intro-r":
          return {
            type: sep.children[1].innerHTML,
            subactions: gen_subactions()
          };
        case "→-intro":
          return {
            type: sep.children[1].innerHTML,
            subactions: gen_subactions()
          };
        case "↔-intro":
          return {
            type: sep.children[1].innerHTML,
            subactions: gen_subactions()
          };
      }
    } else {
      return { type: "done" };
    }
  }

  function save_level() {
    exercises_data[current_exercise].save_data =
      save_level_aux(proof.children[0].children[2].children[0]);
  }

  function load_level() {
    const data = exercises_data[current_exercise].save_data;
    setup();
    if (data) {
      rebuild_level(data);
      check_whether_proof_done();
    } else {
      setup();
    }
  }

  function switch_to_level(n) {
    save_level();
    persistent_save();
    current_exercise = n;
    load_level();
    close_level_panel();
  }

  function populate_level_selector() {
    for (let i = 0; i < exercises_data.length; i++) {
      level_gallery.insertAdjacentHTML("beforeend", `<div class="gallery-item" onclick="switch_to_level(${i})"><div class=gallery-title>Ex. ${i+1}</div><hr/><div class=gallery-description>${tree_to_expr(JSON.parse(exercises_data[i].objective))}</div></div>`);
    }

      for (let i = 0; i < 3; i++) {
     level_gallery.insertAdjacentHTML("beforeend", `<div class=gallery-i-wish-i-didnt-have-to-resort-to-this-dirty-hack></div>`);
    }
  }

  function persistent_save() {
    save_level();
    let exercises_saves = [];
    let exercises_status = [];
    for (let i = 0; i < exercises_data.length; i++) {
      exercises_saves.push(exercises_data[i].save_data);
      exercises_status.push(level_gallery.children[i].classList.contains("known"));
    }
    localStorage.setItem(
      "persistent_state",
      JSON.stringify({
        version: version,
        current_exercise: current_exercise,
        exercises_data: exercises_saves,
        exercises_status: exercises_status,
      })
    );
  }

  function regen_from_persistent() {
    const saved = localStorage.getItem("persistent_state");
    if (saved) {
      state = JSON.parse(saved);
      if (state.version === version) {
        current_exercise = state.current_exercise;
        for (let i = 0; i < exercises_data.length; i++) {
          exercises_data[i].save_data = state.exercises_data[i];
          if (state.exercises_status[i]) {
            level_gallery.children[i].classList.add("known");
          }
        }
      }
    }
  }

  function clear_persistent() {
    const saved = localStorage.removeItem("persistent_state");
  }

  function export_data() {
    save_level();
    persistent_save(); // probably not necessary
    let data = localStorage.getItem("persistent_state");
    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "logic.cool";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function import_data() {
    document.getElementById('file-input').click();
  }

  document.getElementById('file-input').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      const contents = e.target.result;
      localStorage.setItem("persistent_state", contents);
      regen_from_persistent();
      load_level();
    };
    reader.readAsText(file);
  });

  var exercise_mode = false;
  var current_exercise = 0;
  const version = 1;
  function init() {
    populate_level_selector();
    regen_from_persistent();
    load_level();
  }

  window.addEventListener("beforeunload", () => { persistent_save(); });
  window.addEventListener("pagehide", () => { persistent_save(); });
  slider.addEventListener("mousemove", move, false);
  slider.addEventListener("mousedown", startDragging, false);
  slider.addEventListener("mouseup", stopDragging, false);
  slider.addEventListener("mouseleave", stopDragging, false);

  init();
</script>
</html>
